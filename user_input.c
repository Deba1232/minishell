#include "msh.h"

int status;
pid_t child_pid;
char pwd_buf[100], host_name_buf[50], current_running_command[256];

void scan_input(char *prompt, char *input_string){
    // Store the external command list in an array
    extract_external_commands(external_commands);

    // Handle SIGINT and SIGTSTP signals
    signal(SIGINT, signal_handler);
    signal(SIGTSTP, signal_handler);

    while(1){
        gethostname(host_name_buf, sizeof(host_name_buf));

        if(strncmp(prompt, "minishell", 9) == 0){
            printf(ANSI_COLOR_GREEN "%s@%s" ANSI_COLOR_RESET ":" ANSI_COLOR_CYAN "%s" ANSI_COLOR_RESET "$ ", prompt, host_name_buf,getcwd(pwd_buf, sizeof(pwd_buf)));
        }
        else{
            printf("%s", prompt);
        }

        scanf("%[^\n]", input_string);
        
        // Remove '\n' from stdin buffer
        getchar();

        // Check whether input string is provided
        if(strlen(input_string) == 0){
            continue;
        }
        else if(strstr(input_string, "PS1")){   //Check whether the input provided contains PS1 or not

            if(strchr(input_string, ' ') == NULL){
                strcpy(prompt, strstr(input_string, "PS1=") + 4);
            }
            else{
                printf("PS1: command not found\n");
                // Reset the input string to take new input
                memset(input_string, 0, sizeof(input_string));
            }
        }
        else{
            char *cmd = get_command(input_string);
            int cmd_type = check_command_type(cmd);

            if(cmd_type == BUILTIN){
                execute_internal_commands(input_string);
                // Reset the input string to take new input
                memset(input_string, 0, sizeof(input_string));

            }
            else if(cmd_type == EXTERNAL){
                strcpy(current_running_command, input_string);

                // Now create a child process in order to execute the command
                pid_t pid = fork();

                if(pid > 0){    // Parent process
                    child_pid = pid;    // Only parent sets child_pid

                    waitpid(pid, &status, WUNTRACED);   // Should return child process exit code when it's terminated as well as stopped

                    child_pid = 0; // Reset the child pid value
                    memset(input_string, 0, sizeof(input_string));  // Reset the input string to take new input
                }
                else if(pid == 0){  // Child process
                    // If a signal is being generated by the child process, just do default action
                    signal(SIGINT, SIG_DFL);
                    signal(SIGTSTP, SIG_DFL);

                    execute_external_commands(input_string);
                    exit(0);    // Ensure the child process exits after command execution to prevent unintended continuation
                }
                else{
                    perror("fork");
                    exit(EXIT_FAILURE);
                }
            }
            else if(cmd_type == EMPTY_COMMAND){
                continue;
            }
            else{
                printf("%s: command not found\n", input_string);
                // Reset the input string to take new input
                memset(input_string, 0, sizeof(input_string));
            }
        }
    }
}
